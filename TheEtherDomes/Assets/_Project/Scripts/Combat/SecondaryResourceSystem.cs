using System;
using System.Collections.Generic;
using EtherDomes.Data;
using UnityEngine;

namespace EtherDomes.Combat
{
    /// <summary>
    /// Manages secondary resources for classes.
    /// 
    /// Resource Types:
    /// - Rage (Warrior): Generated by dealing/receiving damage, decays out of combat
    /// - Holy Power (Paladin): Generated by specific abilities, does not decay
    /// - Energy (Rogue): 100 max, regenerates 10/s (Requirements 5.2)
    /// - Focus (Hunter): 100 max, regenerates 5/s (Requirements 6.2)
    /// - Combo Points (Rogue): 5 max, generated by abilities, consumed by finishers (Requirements 5.3, 5.4, 5.5)
    /// 
    /// Requirements: 9.3, 5.2, 5.3, 5.4, 5.5, 6.2
    /// </summary>
    public class SecondaryResourceSystem : MonoBehaviour, ISecondaryResourceSystem
    {
        public const float RAGE_MAX = 100f;
        public const float RAGE_DECAY_RATE = 2f;        // Per second out of combat
        public const float RAGE_PER_DAMAGE_DEALT = 5f;  // Per hit
        public const float RAGE_PER_DAMAGE_TAKEN = 3f;  // Per hit received
        
        public const float HOLY_POWER_MAX = 5f;         // 5 points max
        public const float HOLY_POWER_PER_ABILITY = 1f; // Per generator ability

        // Energy constants (Requirements 5.2)
        public const float ENERGY_MAX = 100f;           // 100 max
        public const float ENERGY_REGEN_RATE = 10f;     // 10 per second

        // Focus constants (Requirements 6.2)
        public const float FOCUS_MAX = 100f;            // 100 max
        public const float FOCUS_REGEN_RATE = 5f;       // 5 per second

        // Combo Points constants (Requirements 5.3, 5.4, 5.5)
        public const float COMBO_POINTS_MAX = 5f;       // 5 max
        public const float COMBO_POINT_DAMAGE_MULTIPLIER = 0.2f; // 20% per combo point

        private readonly Dictionary<ulong, ResourceState> _playerResources = new();
        private readonly Dictionary<ulong, int> _comboPoints = new(); // Separate tracking for combo points

        public event Action<ulong, float, float> OnResourceChanged;
        public event Action<ulong, int, int> OnComboPointsChanged; // playerId, current, max

        public void RegisterResource(ulong playerId, SecondaryResourceType resourceType, float maxValue)
        {
            if (resourceType == SecondaryResourceType.None)
            {
                _playerResources.Remove(playerId);
                return;
            }

            float max = maxValue > 0 ? maxValue : GetDefaultMax(resourceType);
            
            _playerResources[playerId] = new ResourceState
            {
                ResourceType = resourceType,
                CurrentValue = 0,
                MaxValue = max
            };

            Debug.Log($"[SecondaryResource] Registered {resourceType} for player {playerId} (Max: {max})");
        }

        public void AddResource(ulong playerId, float amount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (amount <= 0)
                return;

            float oldValue = state.CurrentValue;
            state.CurrentValue = Mathf.Min(state.CurrentValue + amount, state.MaxValue);

            if (state.CurrentValue != oldValue)
            {
                OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
                Debug.Log($"[SecondaryResource] Player {playerId}: +{amount} {state.ResourceType} " +
                          $"({state.CurrentValue}/{state.MaxValue})");
            }
        }

        public bool TrySpendResource(ulong playerId, float amount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return false;

            if (amount <= 0)
                return true;

            if (state.CurrentValue < amount)
                return false;

            state.CurrentValue -= amount;
            OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
            
            Debug.Log($"[SecondaryResource] Player {playerId}: -{amount} {state.ResourceType} " +
                      $"({state.CurrentValue}/{state.MaxValue})");
            
            return true;
        }

        public float GetResource(ulong playerId)
        {
            return _playerResources.TryGetValue(playerId, out var state) ? state.CurrentValue : 0;
        }

        public float GetMaxResource(ulong playerId)
        {
            return _playerResources.TryGetValue(playerId, out var state) ? state.MaxValue : 0;
        }

        public SecondaryResourceType GetResourceType(ulong playerId)
        {
            return _playerResources.TryGetValue(playerId, out var state) 
                ? state.ResourceType 
                : SecondaryResourceType.None;
        }

        public void ApplyDecay(ulong playerId, float deltaTime, bool inCombat)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            // Handle different resource types
            switch (state.ResourceType)
            {
                case SecondaryResourceType.Rage:
                    // Rage decays out of combat
                    if (!inCombat && state.CurrentValue > 0)
                    {
                        float decay = RAGE_DECAY_RATE * deltaTime;
                        float oldValue = state.CurrentValue;
                        state.CurrentValue = Mathf.Max(0, state.CurrentValue - decay);

                        if (state.CurrentValue != oldValue)
                        {
                            OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
                        }
                    }
                    break;

                case SecondaryResourceType.Energy:
                    // Energy regenerates constantly (Requirements 5.2)
                    ApplyRegeneration(playerId, state, ENERGY_REGEN_RATE, deltaTime);
                    break;

                case SecondaryResourceType.Focus:
                    // Focus regenerates constantly (Requirements 6.2)
                    ApplyRegeneration(playerId, state, FOCUS_REGEN_RATE, deltaTime);
                    break;

                // HolyPower and ComboPoints do not decay or regenerate
                default:
                    break;
            }
        }

        /// <summary>
        /// Apply regeneration to a resource.
        /// </summary>
        private void ApplyRegeneration(ulong playerId, ResourceState state, float regenRate, float deltaTime)
        {
            if (state.CurrentValue >= state.MaxValue)
                return;

            float regen = regenRate * deltaTime;
            float oldValue = state.CurrentValue;
            state.CurrentValue = Mathf.Min(state.CurrentValue + regen, state.MaxValue);

            if (state.CurrentValue != oldValue)
            {
                OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
            }
        }

        /// <summary>
        /// Generate rage from dealing damage.
        /// </summary>
        public void GenerateRageFromDamageDealt(ulong playerId, float damageAmount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (state.ResourceType != SecondaryResourceType.Rage)
                return;

            AddResource(playerId, RAGE_PER_DAMAGE_DEALT);
        }

        /// <summary>
        /// Generate rage from taking damage.
        /// </summary>
        public void GenerateRageFromDamageTaken(ulong playerId, float damageAmount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (state.ResourceType != SecondaryResourceType.Rage)
                return;

            AddResource(playerId, RAGE_PER_DAMAGE_TAKEN);
        }

        /// <summary>
        /// Generate holy power from ability use.
        /// </summary>
        public void GenerateHolyPower(ulong playerId, float amount = 1f)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (state.ResourceType != SecondaryResourceType.HolyPower)
                return;

            AddResource(playerId, amount);
        }

        /// <summary>
        /// Get the default max value for a resource type.
        /// </summary>
        public static float GetDefaultMax(SecondaryResourceType resourceType)
        {
            return resourceType switch
            {
                SecondaryResourceType.Rage => RAGE_MAX,
                SecondaryResourceType.HolyPower => HOLY_POWER_MAX,
                SecondaryResourceType.Energy => ENERGY_MAX,
                SecondaryResourceType.Focus => FOCUS_MAX,
                SecondaryResourceType.ComboPoints => COMBO_POINTS_MAX,
                _ => 0
            };
        }

        /// <summary>
        /// Get the resource type for a character class.
        /// Requirements: 10.1, 10.2, 10.3
        /// </summary>
        public static SecondaryResourceType GetResourceTypeForClass(CharacterClass characterClass)
        {
            return characterClass switch
            {
                CharacterClass.Warrior => SecondaryResourceType.Rage,
                CharacterClass.Paladin => SecondaryResourceType.HolyPower,
                CharacterClass.Mage => SecondaryResourceType.None,
                CharacterClass.Priest => SecondaryResourceType.None,
                CharacterClass.Rogue => SecondaryResourceType.Energy,      // Requirements 10.1, 5.2
                CharacterClass.Hunter => SecondaryResourceType.Focus,      // Requirements 10.2, 6.2
                CharacterClass.Warlock => SecondaryResourceType.None,      // Uses Mana only
                CharacterClass.DeathKnight => SecondaryResourceType.None,  // Uses Mana (simplified from runes)
                _ => SecondaryResourceType.None
            };
        }

        /// <summary>
        /// Check if a class uses combo points as an additional resource.
        /// Requirements: 10.3, 5.3
        /// </summary>
        public static bool ClassUsesComboPoints(CharacterClass characterClass)
        {
            return characterClass == CharacterClass.Rogue;
        }

        /// <summary>
        /// Check if a resource type decays out of combat.
        /// </summary>
        public static bool DoesResourceDecay(SecondaryResourceType resourceType)
        {
            return resourceType == SecondaryResourceType.Rage;
        }

        /// <summary>
        /// Check if a resource type regenerates over time.
        /// </summary>
        public static bool DoesResourceRegenerate(SecondaryResourceType resourceType)
        {
            return resourceType == SecondaryResourceType.Energy || 
                   resourceType == SecondaryResourceType.Focus;
        }

        /// <summary>
        /// Get the regeneration rate for a resource type.
        /// </summary>
        public static float GetRegenRate(SecondaryResourceType resourceType)
        {
            return resourceType switch
            {
                SecondaryResourceType.Energy => ENERGY_REGEN_RATE,
                SecondaryResourceType.Focus => FOCUS_REGEN_RATE,
                _ => 0f
            };
        }

        /// <summary>
        /// Clear resource for a player.
        /// </summary>
        public void ClearResource(ulong playerId)
        {
            _playerResources.Remove(playerId);
            _comboPoints.Remove(playerId);
        }

        /// <summary>
        /// Clear all resources.
        /// </summary>
        public void ClearAll()
        {
            _playerResources.Clear();
            _comboPoints.Clear();
        }

        #region Combo Points (Requirements 5.3, 5.4, 5.5)

        /// <summary>
        /// Register combo points for a player (Rogue).
        /// </summary>
        public void RegisterComboPoints(ulong playerId)
        {
            _comboPoints[playerId] = 0;
            Debug.Log($"[SecondaryResource] Registered Combo Points for player {playerId}");
        }

        /// <summary>
        /// Get current combo points for a player.
        /// </summary>
        public int GetComboPoints(ulong playerId)
        {
            return _comboPoints.TryGetValue(playerId, out var points) ? points : 0;
        }

        /// <summary>
        /// Get max combo points (always 5).
        /// </summary>
        public int GetMaxComboPoints()
        {
            return (int)COMBO_POINTS_MAX;
        }

        /// <summary>
        /// Add a combo point from a generator ability.
        /// Requirements: 5.4
        /// </summary>
        public void AddComboPoint(ulong playerId, int amount = 1)
        {
            if (!_comboPoints.ContainsKey(playerId))
            {
                RegisterComboPoints(playerId);
            }

            int oldPoints = _comboPoints[playerId];
            int maxPoints = (int)COMBO_POINTS_MAX;
            _comboPoints[playerId] = Mathf.Min(_comboPoints[playerId] + amount, maxPoints);

            if (_comboPoints[playerId] != oldPoints)
            {
                OnComboPointsChanged?.Invoke(playerId, _comboPoints[playerId], maxPoints);
                Debug.Log($"[SecondaryResource] Player {playerId}: +{amount} Combo Point ({_comboPoints[playerId]}/{maxPoints})");
            }
        }

        /// <summary>
        /// Consume all combo points for a finisher ability.
        /// Returns the number of combo points consumed.
        /// Requirements: 5.5
        /// </summary>
        public int ConsumeAllComboPoints(ulong playerId)
        {
            if (!_comboPoints.TryGetValue(playerId, out var points) || points <= 0)
                return 0;

            int consumed = points;
            _comboPoints[playerId] = 0;
            
            OnComboPointsChanged?.Invoke(playerId, 0, (int)COMBO_POINTS_MAX);
            Debug.Log($"[SecondaryResource] Player {playerId}: Consumed {consumed} Combo Points");
            
            return consumed;
        }

        /// <summary>
        /// Check if player has at least one combo point.
        /// </summary>
        public bool HasComboPoints(ulong playerId)
        {
            return _comboPoints.TryGetValue(playerId, out var points) && points > 0;
        }

        /// <summary>
        /// Calculate damage multiplier based on combo points consumed.
        /// Formula: 1 + (comboPoints * COMBO_POINT_DAMAGE_MULTIPLIER)
        /// Requirements: 5.5
        /// </summary>
        public float CalculateComboPointDamageMultiplier(int comboPoints)
        {
            return 1f + (comboPoints * COMBO_POINT_DAMAGE_MULTIPLIER);
        }

        #endregion

        private class ResourceState
        {
            public SecondaryResourceType ResourceType;
            public float CurrentValue;
            public float MaxValue;
        }
    }
}
