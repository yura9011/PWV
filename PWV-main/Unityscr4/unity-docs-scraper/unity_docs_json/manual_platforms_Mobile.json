{
  "name": "manual_platforms_Mobile",
  "type": "manual",
  "description": "",
  "content": "// Unity Manual: Input_Mobile\n// URL: https://docs.unity3d.com/Manual/MobileInput.html\n\nInput\nLegacy Input\nMobile device input\nInput Manager\nIME in Unity\nMobile device input\nImportant\n: This page documents part of the\nInput Manager\nSettings where you can define all the different input axes, buttons and controls for your project.\nMore info\nSee in\nGlossary\nsystem, which is a legacy feature and not recommended for new projects. For mobile device input in new projects, use the\nInput System Package\n.\nOn mobile devices, the\nInput\nclass offers access to touchscreen, accelerometer and geographical/location input.\nAccess to keyboard on mobile devices is provided via the\nMobile keyboard\n.\nMulti-touch screen\nThe iPhone, iPad and iPod Touch devices are capable of tracking up to five fingers touching the screen simultaneously. You can retrieve the status of each finger touching the screen during the last frame by accessing the\nInput.touches\nproperty array.\nAndroid devices don’t have a unified limit on how many fingers they track. Instead, it varies from device to device and can be anything from two-touch on older devices to five fingers on some newer devices.\nEach finger touch is represented by an\nInput.Touch\ndata structure\nThe following example script shoots a ray whenever the user taps on the screen:\nusing UnityEngine;\n\n\n\npublic class TouchInput : MonoBehaviour\n\n{\n\n    GameObject particle;\n\n\n\n    void Update()\n\n    {\n\n        foreach(Touch touch in Input.touches)\n\n        {\n\n            if (touch.phase == TouchPhase.Began)\n\n            {\n\n                // Construct a ray from the current touch coordinates\n\n                Ray ray = Camera.main.ScreenPointToRay(touch.position);\n\n                if (Physics.Raycast(ray))\n\n                {\n\n                    // Create a particle if hit\n\n                    Instantiate(particle, transform.position, transform.rotation);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\nMouse simulation\nOn top of native touch support Unity iOS/Android provides a mouse simulation. You can use mouse functionality from the standard\nInput\nclass. Note that iOS/Android devices are designed to support multiple finger touch. Using the mouse functionality will support just a single finger touch. Also, finger touch on mobile devices can move from one area to another with no movement between them. Mouse simulation on mobile devices will provide movement, so is very different compared to touch input. The recommendation is to use the mouse simulation during early development but to use touch input as soon as possible.\nAccelerometer\nAs the mobile device moves, a built-in accelerometer reports linear acceleration\n\nchanges along the three primary axes in three-dimensional space. Acceleration\n\nalong each axis is reported directly by the hardware as G-force values. A value\n\nof 1.0 represents a load of about +1g along a given axis while a value of –1.0\n\nrepresents –1g. If you hold the device upright (with the home button at the\n\nbottom) in front of you, the X axis is positive along the right, the Y axis is\n\npositive directly up, and the Z axis is positive pointing toward you.\nYou can retrieve the accelerometer value by accessing the\nInput.acceleration\nproperty.\nThe following is an example script which will move an object using the accelerometer:\nusing UnityEngine;\n\n\n\npublic class Accelerometer : MonoBehaviour\n\n{\n\n    float speed = 10.0f;\n\n\n\n    void Update()\n\n    {\n\n        Vector3 dir = Vector3.zero;\n\n        // we assume that the device is held parallel to the ground\n\n        // and the Home button is in the right hand\n\n\n\n        // remap the device acceleration axis to game coordinates:\n\n        // 1) XY plane of the device is mapped onto XZ plane\n\n        // 2) rotated 90 degrees around Y axis\n\n\n\n        dir.x = -Input.acceleration.y;\n\n        dir.z = Input.acceleration.x;\n\n\n\n        // clamp acceleration vector to the unit sphere\n\n        if (dir.sqrMagnitude > 1)\n\n            dir.Normalize();\n\n\n\n        // Make it move 10 meters per second instead of 10 meters per frame...\n\n        dir *= Time.deltaTime;\n\n\n\n        // Move object\n\n        transform.Translate(dir * speed);\n\n    }\n\n}\nLow-Pass Filter\nAccelerometer readings can be jerky and noisy. Applying low-pass filtering on the signal allows you to smooth it and get rid of high frequency noise.\nThe following script shows you how to apply low-pass filtering to accelerometer readings:\nusing UnityEngine;\n\n\n\npublic class LowPassFilterExample : MonoBehaviour\n\n{\n\n    float accelerometerUpdateInterval = 1.0f / 60.0f;\n\n    float lowPassKernelWidthInSeconds = 1.0f;\n\n\n\n    private float lowPassFilterFactor;\n\n    private Vector3 lowPassValue = Vector3.zero;\n\n\n\n    void Start()\n\n    {\n\n        lowPassFilterFactor = accelerometerUpdateInterval / lowPassKernelWidthInSeconds;\n\n        lowPassValue = Input.acceleration;\n\n    }\n\n\n\n    private void Update()\n\n    {\n\n        lowPassValue = LowPassFilterAccelerometer(lowPassValue);\n\n    }\n\n\n\n    Vector3 LowPassFilterAccelerometer(Vector3 prevValue)\n\n    {\n\n        Vector3 newValue = Vector3.Lerp(prevValue, Input.acceleration, lowPassFilterFactor);\n\n        return newValue;\n\n    }\n\n}\nThe greater the value of\nLowPassKernelWidthInSeconds\n, the slower the filtered value will converge towards the current input sample (and vice versa).\nI’d like as much precision as possible when reading the accelerometer. What should I do?\nReading the\nInput.acceleration\nvariable does not equal sampling the hardware. Put simply, Unity samples the hardware at a frequency of 60Hz and stores the result into the variable. In reality, things are a little bit more complicated – accelerometer sampling doesn’t occur at consistent time intervals, if under significant CPU loads. As a result, the system might report 2 samples during one frame, then 1 sample during the next frame.\nYou can access all measurements executed by accelerometer during the frame. The following code will illustrate a simple average of all the accelerometer events that were collected within the last frame:\npublic class AccelerationEvents : MonoBehaviour\n\n{ \n\n    void Update()\n\n    {\n\n        GetAccelerometerValue();\n\n    }\n\n\n\n    Vector3 GetAccelerometerValue()\n\n    {\n\n        Vector3 acc = Vector3.zero;\n\n        float period = 0.0f;\n\n\n\n        foreach(AccelerationEvent evnt in Input.accelerationEvents)\n\n        {\n\n            acc += evnt.acceleration * evnt.deltaTime;\n\n            period += evnt.deltaTime;\n\n        }\n\n        if (period > 0)\n\n        {\n\n            acc *= 1.0f / period;\n\n        }\n\n        return acc;\n\n    }\n\n}\nInput Manager\nIME in Unity\n",
  "properties": []
}