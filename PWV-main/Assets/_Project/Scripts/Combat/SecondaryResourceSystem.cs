using System;
using System.Collections.Generic;
using EtherDomes.Data;
using UnityEngine;

namespace EtherDomes.Combat
{
    /// <summary>
    /// Manages secondary resources for classes.
    /// 
    /// Resource Types (Phase 2 - 8 Classes):
    /// - Mana: Cruzado, MaestroElemental, Clerigo, MedicoBrujo (regenerates over time)
    /// - Colera: Protector, Berserker (generated by damage, decays out of combat)
    /// - Energia: Arquero (regenerates over time)
    /// - EnergiaRunica + Runas: CaballeroRunico (runic power + 6 runes)
    /// </summary>
    public class SecondaryResourceSystem : MonoBehaviour, ISecondaryResourceSystem
    {
        // Mana constants
        public const float MANA_MAX = 100f;
        public const float MANA_REGEN_RATE = 2f;        // Per second (base, scales with spirit)

        // Colera (Rage) constants
        public const float COLERA_MAX = 100f;
        public const float COLERA_DECAY_RATE = 2f;      // Per second out of combat
        public const float COLERA_PER_DAMAGE_DEALT = 5f;
        public const float COLERA_PER_DAMAGE_TAKEN = 3f;

        // Energia constants (Arquero)
        public const float ENERGIA_MAX = 100f;
        public const float ENERGIA_REGEN_RATE = 10f;    // Per second

        // Energia Runica constants (CaballeroRunico)
        public const float ENERGIA_RUNICA_MAX = 100f;
        public const float ENERGIA_RUNICA_DECAY_RATE = 1f;  // Per second out of combat
        public const int RUNAS_MAX = 6;                     // 6 runes total
        public const float RUNA_REGEN_TIME = 10f;           // Seconds per rune regeneration

        // Legacy constants (for backward compatibility)
        public const float RAGE_MAX = COLERA_MAX;
        public const float RAGE_DECAY_RATE = COLERA_DECAY_RATE;
        public const float RAGE_PER_DAMAGE_DEALT = COLERA_PER_DAMAGE_DEALT;
        public const float RAGE_PER_DAMAGE_TAKEN = COLERA_PER_DAMAGE_TAKEN;
        public const float ENERGY_MAX = ENERGIA_MAX;
        public const float ENERGY_REGEN_RATE = ENERGIA_REGEN_RATE;
        public const float FOCUS_MAX = ENERGIA_MAX;
        public const float FOCUS_REGEN_RATE = ENERGIA_REGEN_RATE;
        public const float HOLY_POWER_MAX = MANA_MAX;
        public const float HOLY_POWER_PER_ABILITY = 1f;

        // Combo Points (legacy, may be removed)
        public const float COMBO_POINTS_MAX = 5f;
        public const float COMBO_POINT_DAMAGE_MULTIPLIER = 0.2f;

        private readonly Dictionary<ulong, ResourceState> _playerResources = new();
        private readonly Dictionary<ulong, RuneState> _playerRunes = new();
        private readonly Dictionary<ulong, int> _comboPoints = new();

        public event Action<ulong, float, float> OnResourceChanged;
        public event Action<ulong, int, int> OnRunesChanged;       // playerId, available, max
        public event Action<ulong, int, int> OnComboPointsChanged;

        #region Resource Registration

        public void RegisterResource(ulong playerId, SecondaryResourceType resourceType, float maxValue)
        {
            if (resourceType == SecondaryResourceType.None)
            {
                _playerResources.Remove(playerId);
                return;
            }

            float max = maxValue > 0 ? maxValue : GetDefaultMax(resourceType);
            float startValue = ShouldStartFull(resourceType) ? max : 0;
            
            _playerResources[playerId] = new ResourceState
            {
                ResourceType = resourceType,
                CurrentValue = startValue,
                MaxValue = max
            };

            Debug.Log($"[SecondaryResource] Registered {resourceType} for player {playerId} (Max: {max})");
        }

        /// <summary>
        /// Register runes for CaballeroRunico (6 runes).
        /// </summary>
        public void RegisterRunes(ulong playerId)
        {
            _playerRunes[playerId] = new RuneState
            {
                AvailableRunes = RUNAS_MAX,
                MaxRunes = RUNAS_MAX,
                RegenTimers = new float[RUNAS_MAX]
            };
            Debug.Log($"[SecondaryResource] Registered {RUNAS_MAX} Runes for player {playerId}");
        }

        #endregion

        #region Resource Operations

        public void AddResource(ulong playerId, float amount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (amount <= 0)
                return;

            float oldValue = state.CurrentValue;
            state.CurrentValue = Mathf.Min(state.CurrentValue + amount, state.MaxValue);

            if (state.CurrentValue != oldValue)
            {
                OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
            }
        }

        public bool TrySpendResource(ulong playerId, float amount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return false;

            if (amount <= 0)
                return true;

            if (state.CurrentValue < amount)
                return false;

            state.CurrentValue -= amount;
            OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
            return true;
        }

        public float GetResource(ulong playerId)
        {
            return _playerResources.TryGetValue(playerId, out var state) ? state.CurrentValue : 0;
        }

        public float GetMaxResource(ulong playerId)
        {
            return _playerResources.TryGetValue(playerId, out var state) ? state.MaxValue : 0;
        }

        public SecondaryResourceType GetResourceType(ulong playerId)
        {
            return _playerResources.TryGetValue(playerId, out var state) 
                ? state.ResourceType 
                : SecondaryResourceType.None;
        }

        #endregion

        #region Decay and Regeneration

        public void ApplyDecay(ulong playerId, float deltaTime, bool inCombat)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            switch (state.ResourceType)
            {
                case SecondaryResourceType.Colera:
                    // Colera decays out of combat
                    if (!inCombat && state.CurrentValue > 0)
                    {
                        ApplyResourceDecay(playerId, state, COLERA_DECAY_RATE, deltaTime);
                    }
                    break;

                case SecondaryResourceType.EnergiaRunica:
                    // Energia Runica decays out of combat
                    if (!inCombat && state.CurrentValue > 0)
                    {
                        ApplyResourceDecay(playerId, state, ENERGIA_RUNICA_DECAY_RATE, deltaTime);
                    }
                    // Also regenerate runes
                    ApplyRuneRegeneration(playerId, deltaTime);
                    break;

                case SecondaryResourceType.Energia:
                    // Energia regenerates constantly
                    ApplyRegeneration(playerId, state, ENERGIA_REGEN_RATE, deltaTime);
                    break;

                case SecondaryResourceType.Mana:
                    // Mana regenerates (faster out of combat)
                    float manaRegen = inCombat ? MANA_REGEN_RATE * 0.5f : MANA_REGEN_RATE;
                    ApplyRegeneration(playerId, state, manaRegen, deltaTime);
                    break;
            }
        }

        private void ApplyResourceDecay(ulong playerId, ResourceState state, float decayRate, float deltaTime)
        {
            float decay = decayRate * deltaTime;
            float oldValue = state.CurrentValue;
            state.CurrentValue = Mathf.Max(0, state.CurrentValue - decay);

            if (state.CurrentValue != oldValue)
            {
                OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
            }
        }

        private void ApplyRegeneration(ulong playerId, ResourceState state, float regenRate, float deltaTime)
        {
            if (state.CurrentValue >= state.MaxValue)
                return;

            float regen = regenRate * deltaTime;
            float oldValue = state.CurrentValue;
            state.CurrentValue = Mathf.Min(state.CurrentValue + regen, state.MaxValue);

            if (state.CurrentValue != oldValue)
            {
                OnResourceChanged?.Invoke(playerId, state.CurrentValue, state.MaxValue);
            }
        }

        #endregion

        #region Colera (Rage) Generation

        public void GenerateColeraFromDamageDealt(ulong playerId, float damageAmount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (state.ResourceType != SecondaryResourceType.Colera)
                return;

            AddResource(playerId, COLERA_PER_DAMAGE_DEALT);
        }

        public void GenerateColeraFromDamageTaken(ulong playerId, float damageAmount)
        {
            if (!_playerResources.TryGetValue(playerId, out var state))
                return;

            if (state.ResourceType != SecondaryResourceType.Colera)
                return;

            AddResource(playerId, COLERA_PER_DAMAGE_TAKEN);
        }

        // Legacy aliases
        public void GenerateRageFromDamageDealt(ulong playerId, float damageAmount) 
            => GenerateColeraFromDamageDealt(playerId, damageAmount);
        public void GenerateRageFromDamageTaken(ulong playerId, float damageAmount) 
            => GenerateColeraFromDamageTaken(playerId, damageAmount);

        #endregion

        #region Runes (CaballeroRunico)

        public int GetAvailableRunes(ulong playerId)
        {
            return _playerRunes.TryGetValue(playerId, out var state) ? state.AvailableRunes : 0;
        }

        public bool TrySpendRune(ulong playerId, int count = 1)
        {
            if (!_playerRunes.TryGetValue(playerId, out var state))
                return false;

            if (state.AvailableRunes < count)
                return false;

            state.AvailableRunes -= count;
            
            // Start regeneration timers for spent runes
            int runesSpent = count;
            for (int i = 0; i < RUNAS_MAX && runesSpent > 0; i++)
            {
                if (state.RegenTimers[i] <= 0)
                {
                    state.RegenTimers[i] = RUNA_REGEN_TIME;
                    runesSpent--;
                }
            }

            OnRunesChanged?.Invoke(playerId, state.AvailableRunes, state.MaxRunes);
            return true;
        }

        private void ApplyRuneRegeneration(ulong playerId, float deltaTime)
        {
            if (!_playerRunes.TryGetValue(playerId, out var state))
                return;

            bool changed = false;
            for (int i = 0; i < RUNAS_MAX; i++)
            {
                if (state.RegenTimers[i] > 0)
                {
                    state.RegenTimers[i] -= deltaTime;
                    if (state.RegenTimers[i] <= 0)
                    {
                        state.RegenTimers[i] = 0;
                        state.AvailableRunes = Mathf.Min(state.AvailableRunes + 1, state.MaxRunes);
                        changed = true;
                    }
                }
            }

            if (changed)
            {
                OnRunesChanged?.Invoke(playerId, state.AvailableRunes, state.MaxRunes);
            }
        }

        #endregion

        #region Static Helpers

        public static float GetDefaultMax(SecondaryResourceType resourceType)
        {
            return resourceType switch
            {
                SecondaryResourceType.Mana => MANA_MAX,
                SecondaryResourceType.Colera => COLERA_MAX,
                SecondaryResourceType.Energia => ENERGIA_MAX,
                SecondaryResourceType.EnergiaRunica => ENERGIA_RUNICA_MAX,
                _ => 0
            };
        }

        public static SecondaryResourceType GetResourceTypeForClass(CharacterClass characterClass)
        {
            return (int)characterClass switch
            {
                0 => SecondaryResourceType.Mana,           // Cruzado
                1 => SecondaryResourceType.Colera,         // Protector
                2 => SecondaryResourceType.Colera,         // Berserker
                3 => SecondaryResourceType.Energia,        // Arquero
                4 => SecondaryResourceType.Mana,           // MaestroElemental
                5 => SecondaryResourceType.EnergiaRunica,  // CaballeroRunico
                6 => SecondaryResourceType.Mana,           // Clerigo
                7 => SecondaryResourceType.Mana,           // MedicoBrujo
                _ => SecondaryResourceType.None
            };
        }

        /// <summary>
        /// Check if CaballeroRunico uses runes as additional resource.
        /// </summary>
        public static bool ClassUsesRunes(CharacterClass characterClass)
        {
            return characterClass == CharacterClass.CaballeroRunico;
        }

        public static bool DoesResourceDecay(SecondaryResourceType resourceType)
        {
            return resourceType == SecondaryResourceType.Colera || 
                   resourceType == SecondaryResourceType.EnergiaRunica;
        }

        public static bool DoesResourceRegenerate(SecondaryResourceType resourceType)
        {
            return resourceType == SecondaryResourceType.Energia || 
                   resourceType == SecondaryResourceType.Mana;
        }

        public static float GetRegenRate(SecondaryResourceType resourceType)
        {
            return resourceType switch
            {
                SecondaryResourceType.Energia => ENERGIA_REGEN_RATE,
                SecondaryResourceType.Mana => MANA_REGEN_RATE,
                _ => 0f
            };
        }

        /// <summary>
        /// Check if resource should start at full (Mana, Energia) or empty (Colera).
        /// </summary>
        private static bool ShouldStartFull(SecondaryResourceType resourceType)
        {
            return resourceType == SecondaryResourceType.Mana || 
                   resourceType == SecondaryResourceType.Energia;
        }

        #endregion

        #region Cleanup

        public void ClearResource(ulong playerId)
        {
            _playerResources.Remove(playerId);
            _playerRunes.Remove(playerId);
            _comboPoints.Remove(playerId);
        }

        public void ClearAll()
        {
            _playerResources.Clear();
            _playerRunes.Clear();
            _comboPoints.Clear();
        }

        #endregion

        #region Legacy Combo Points (may be removed)

        public void RegisterComboPoints(ulong playerId)
        {
            _comboPoints[playerId] = 0;
        }

        public int GetComboPoints(ulong playerId)
        {
            return _comboPoints.TryGetValue(playerId, out var points) ? points : 0;
        }

        public int GetMaxComboPoints() => (int)COMBO_POINTS_MAX;

        public void AddComboPoint(ulong playerId, int amount = 1)
        {
            if (!_comboPoints.ContainsKey(playerId))
                RegisterComboPoints(playerId);

            int oldPoints = _comboPoints[playerId];
            _comboPoints[playerId] = Mathf.Min(_comboPoints[playerId] + amount, (int)COMBO_POINTS_MAX);

            if (_comboPoints[playerId] != oldPoints)
                OnComboPointsChanged?.Invoke(playerId, _comboPoints[playerId], (int)COMBO_POINTS_MAX);
        }

        public int ConsumeAllComboPoints(ulong playerId)
        {
            if (!_comboPoints.TryGetValue(playerId, out var points) || points <= 0)
                return 0;

            _comboPoints[playerId] = 0;
            OnComboPointsChanged?.Invoke(playerId, 0, (int)COMBO_POINTS_MAX);
            return points;
        }

        public bool HasComboPoints(ulong playerId)
        {
            return _comboPoints.TryGetValue(playerId, out var points) && points > 0;
        }

        public float CalculateComboPointDamageMultiplier(int comboPoints)
        {
            return 1f + (comboPoints * COMBO_POINT_DAMAGE_MULTIPLIER);
        }

        // Legacy alias
        public void GenerateHolyPower(ulong playerId, float amount = 1f) => AddResource(playerId, amount);
        public static bool ClassUsesComboPoints(CharacterClass characterClass) => false;

        #endregion

        #region State Classes

        private class ResourceState
        {
            public SecondaryResourceType ResourceType;
            public float CurrentValue;
            public float MaxValue;
        }

        private class RuneState
        {
            public int AvailableRunes;
            public int MaxRunes;
            public float[] RegenTimers;
        }

        #endregion
    }
}
