{
  "name": "manual_graphics_Graphics",
  "type": "manual",
  "description": "",
  "content": "// Unity Manual: Optimization_Graphics\n// URL: https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html\n\nOptimization\nGraphics performance and profiling\nReduce rendering work on the CPU or GPU\nGraphics performance and profiling\nCollect rendering performance data\nReduce rendering work on the CPU or GPU\nThis page contains some simple guidelines for optimzing rendering performance in your application.\nBefore you begin: locate and understand the problem\nBefore you make any changes, you must profile your application to identify the cause of the problem. If you attempt to solve a performance problem before you understand its cause, you might waste your time or make the problem worse. Additionally, rendering-related performance problems can occur on the CPU or the GPU. Strategies for fixing these problems are quite different, so it’s important to understand where your problem is before taking any action.\nThe following article on the Unity Learn site is a comprehensive introduction to graphics performance, and contains information on identifying and fixing problems:\nFixing performance problems\n. If you are not yet familiar with this subject, read the article before following any of the advice on this page.\nReducing the CPU cost of rendering\nUsually, the greatest contributor to CPU rendering time is the cost of sending rendering commands to the GPU. Rendering commands include draw calls (commands to draw geometry), and commands to change the settings on the GPU before drawing the geometry. If this is the case, consider these options:\nYou can reduce the number of objects that Unity renders.\nConsider reducing the overall number of objects in the\nscene\nA Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces.\nMore info\nSee in\nGlossary\n: for example, use a\nskybox\nA special type of Material used to represent skies. Usually six-sided.\nMore info\nSee in\nGlossary\nto create the effect of distant geometry.\nPerform more rigorous culling, so that Unity draws fewer objects. Consider using\nocclusion culling\nA process that disables rendering GameObjects that are hidden (occluded) from the view of the camera.\nMore info\nSee in\nGlossary\nto prevent Unity from drawing objects that are hidden behind other objects, reducing the far clip plane of a\nCamera\nA component which creates an image of a particular viewpoint in your scene. The output is either drawn to the screen or captured as a texture.\nMore info\nSee in\nGlossary\nso that more distant objects fall outside its frustum, or, for a more fine-grained approach, putting objects into\nseparate layers\nand setting up per-layer cull distances with\nCamera.layerCullDistances\n.\nYou can reduce the number of times that Unity renders each object.\nUse\nlightmapping\nto “bake” (pre-compute) lighting and shadows where appropriate. This increases build time, runtime memory usage and storage space, but can improve runtime performance.\nIf your application uses\nForward rendering\nA rendering path that renders each object in one or more passes, depending on lights that affect the object. Lights themselves are also treated differently by Forward Rendering, depending on their settings and intensity.\nMore info\nSee in\nGlossary\n, reduce the number of per-pixel real-time lights that affect objects. For more information, see\nForward rendering path\n.\nReal-time shadows can be very resource-intensive, so use them sparingly and efficiently. For more information, see\nShadow troubleshooting: Shadow performance\n.\nIf your application uses\nReflection Probes\nA rendering component that captures a spherical view of its surroundings in all directions, rather like a camera. The captured image is then stored as a Cubemap that can be used by objects with reflective materials.\nMore info\nSee in\nGlossary\n, ensure that you optimize their usage. For more information, see\nReflection Probe performance\nYou can reduce the amount of work that Unity must do to prepare and send rendering commands, usually by sending them to the GPU in more efficient “batches”. There are a few different ways to achieve this: for more information, see\nOptimizing draw calls\n.\nMany of these approaches will also reduce the work required on the GPU; for example, reducing the overall number of objects that Unity renders in a frame will result in a reduced workload for both the CPU and the GPU.\nReducing the GPU cost of rendering\nThere are three main reasons why the GPU might fail to complete its work in time to render a frame.\nIf an application is limited by fill rate, the GPU is trying to draw more\npixels\nThe smallest unit in a computer image. Pixel size depends on your screen resolution. Pixel lighting is calculated at every screen pixel.\nMore info\nSee in\nGlossary\nper frame than it can handle. If this is the case, consider these options:\nIdentify and reduce overdraw in your application. The most common contributors to overdraw are overlapping transparent elements, such as UI,\nparticles\nA small, simple image or mesh that is emitted by a particle system. A particle system can display and move particles in great numbers to represent a fluid or amorphous entity. The effect of all the particles together creates the impression of the complete entity, such as smoke.\nMore info\nSee in\nGlossary\nand\nsprites\nA 2D graphic objects. If you are used to working in 3D, Sprites are essentially just standard textures but there are special techniques for combining and managing sprite textures for efficiency and convenience during development.\nMore info\nSee in\nGlossary\n. In the Unity Editor, use the\nOverdraw Draw mode\nto identify areas where this is a problem.\nReduce the execution cost of fragment shaders. For information about\nshader\nA program that runs on the GPU.\nMore info\nSee in\nGlossary\nperformance, see the\nShader Performance\npage.\nIf you’re using Unity’s built-in shaders, pick ones from the\nMobile\nor\nUnlit\ncategories. They work on non-mobile platforms as well, but are simplified and approximated versions of the more complex shaders.\nDynamic Resolution\nA Camera setting that allows you to dynamically scale individual render targets to reduce workload on the GPU.\nMore info\nSee in\nGlossary\nis a Unity feature that allows you to dynamically scale individual render targets.\nIf an application is limited by memory bandwidth, the GPU is trying to read and write more data to its dedicated memory than it can handle in a frame. This usually means that that there are too many or textures, or that textures are too large. If this is the case, consider these options:\nEnable\nmipmaps\nfor textures whose distance from the camera varies at runtime (for example, most textures used in a 3D scene). This increases memory usage and storage space for these textures, but can improve runtime GPU performance.\nUse suitable\ncompression formats\nto decrease the size of your textures in memory. This can result in faster load times, a smaller memory footprint, and improved GPU rendering performance. Compressed textures only use a fraction of the memory bandwidth needed for uncompressed textures.\nIf an appliction is limited by vertex processing, this means that the GPU is trying to process more vertices than it can handle in a frame. If this is the case, consider these options:\nReduce the execution cost of\nvertex shaders\nA program that runs on each vertex of a 3D model when the model is being rendered.\nMore info\nSee in\nGlossary\n. For information about shader performance, see the\nShader Performance\npage.\nOptimize your geometry: don’t use any more triangles than necessary, and try to keep the number of UV mapping seams and hard edges (doubled-up vertices) as low as possible. For more information, see\nCreating models for optimal performance\n.\nUse the\nLevel Of Detail\nThe\nLevel Of Detail\n(LOD) technique is an optimization that reduces the number of triangles that Unity has to render for a GameObject when its distance from the Camera increases.\nMore info\nSee in\nGlossary\nsystem.\nReducing the frequency of rendering\nSometimes, it might benefit your application to reduce the rendering frame rate. This doesn’t reduce the CPU or GPU cost of rendering a single frame, but it reduces the frequency with which Unity does so without affecting the frequency of other operations (such as script execution).\nYou can reduce the rendering frame rate for parts of your application, or for the whole application. Reducing the rendering frame rate to prevents unnecessary power usage, prolongs battery life, and prevent device temperature from rising to a point where the CPU frequency may be throttled. This is particularly useful on handheld devices.\nIf profiling reveals that rendering consumes a significant proportion of the resources for your application, consider which parts of your application might benefit from this. Common use cases include menus or pause screens, turn based games where the game is awaiting input, and applications where the content is mostly static, such as automotive UI.\nTo prevent input lag, you can temporarily increase the rendering frame rate for the duration of the input so that it still feels responsive.\nTo adjust the rendering frame rate, use the\nOnDemandRendering\nAPI. The API works particularly well with\nAdaptive Performance\n.\nNote:\nVR\nVirtual Reality\nMore info\nSee in\nGlossary\napplications don’t support On Demand Rendering. Not rendering every frame causes the visuals to be out of sync with head movement and might increase the risk of motion sickness.\nAdditional resources\nReduce rendering work on the GPU or CPU in URP\nOptimize for untethered XR devices in URP\nGraphics rendering: Getting the best performance with Unity 6\nPerformance tips and tricks from a Unity consultant\nGraphics performance and profiling\nCollect rendering performance data\n",
  "properties": []
}